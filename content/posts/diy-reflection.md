---
title: "DIY reflection"
date: 2018-04-08T15:31:25+02:00
draft: true
---

Whenever I'm writing a backend service in C++ there happen to be a problem with serialization of structures from/to a persistent store. Be it a database, network protocol, file, or anything. Basically anytime you're forced to write code such as:


{{< highlight cpp >}}
// myPersistentStore is a connection to a database,
// and method below runs a SQL query.
myPersistentStore.query(R"SQL(
  "SELECT "field1", "field2", "field3", ..., "field42"
  FROM "account")SQL);
// fetchAll returns a iterable view on database cursor,
// and row contains a map-like object where you can access value of a
// specific column by its name.
for (auto&& row : myPersistentStore.fetchAll()) {
  MyStructure myStructure;
  myStructure.field1 = row["field1"];
  myStructure.field2 = row["field2"];
  myStructure.field3 = std::stoi(row["field3"]);
  // ...
  myStructure.field42 = std::stoull(row["field42"]);
}

{{< / highlight >}}

If you have a fairly big database, with large amount of different fields it can be headache to extend anything -- and this means a lot of repetition.

There exists at least few ORMs for C++ which I can use right now, which sort of solves this problem for me in the way that I wouldn't have to write SQL by hand anymore. What if I don't have database, but a binary file for instance. I need a solution that is flexible, and doesn't enforce a whole new paradigm.

I want a solution that decouples the definition from actual serialization/deserialization.

What I really need is to list all the fields with their types and names. This sounds very much like reflection [https://wg21.link/N4766](which is a working draft ready for publication) and its very likely it will be a part of C++20.

How to implement our own reflection pre-C++20 in a least intrusive way possible?

# Preprocessor magic

For instance I can abuse preprocessor macros to enrich my structures with custom annotations that will provide me a way to get a list of properties by their names.

{{< highlight cpp >}}
struct Person: AutoProp<Person> {
  AUTOPROP_BEGIN(Person);

  std::string AUTOPROP(first_name);
  std::string AUTOPROP(last_name);

  int AUTOPROP(age);

  AUTOPROP_END();
};
{{< / highlight >}}

Macro `AUTOPROP_BEGIN` woulld generate a "prolog" of the class: an unique method that returns no attributes. Everytime `AUTOPROP` would be called it has to generate a new unique method, that would chain result of a method generated above it, with address and name of the property itself. At the end `AUTOPROP_END` shall generate a predictable method that calls the unique method generated above it which will predictably return a list of attributes in runtime.

Class `AutoProp<>` would expose additional methods such as `forEach` for enumerating that would use the auxilary methods generated by those macros. This base class would ingest those randomly generated methods through [https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern](CRTP) and expose an API for the user with additional methods such as `forEach()`. 



Generated code will look similiar to:

{{< highlight cpp >}}
struct Person: AutoProp<Person> {
// Prolog
static constexpr Empty getAttributes0() { return {}; }

std::string first_name;
static constexpr auto getAttributes1() {
  return chain(
    getAttributes0(),
    makeAttribute(&Person::first_name, "first_name")); }
std::string last_name;
static constexpr auto getAttributes2() {
  return chain(
    getAttributes1(),
    makeAttribute(&Person::last_name, "last_name")); }
int age;
static constexpr auto getAttributes3() {
  return chain(
    getAttributes2(),
    makeAttribute(&Person::age, "age")); }

// Epilog
constexpr auto getAttributes() { return getAttributes3(); }
{{< / highlight >}}

Now calling `getAttributes` produces an instance of type:

```
Node<
  Node<
    Node<
      Empty,
      Attribute<Person, std::string > >,
    Attribute<Person, std::string > >,
  Attribute<Person, int> > >
```

Where:

{{< highlight cpp >}}
struct Empty {};

template <typename Head, typename Tail> struct Node {
  Head head;
  Tail tail;
};

template <typename T, typename R> struct Attribute {
  const char *name; // This is the name of the attribute
  R(T::*pointer); // Pointer-to-member
};
{{< / highlight >}}

This is our DIY reflection type that holds all the information of attributes, their types, and names.

This can be enumerated with a simple recursive function:

{{< highlight cpp >}}
template <typename T, typename Func>
constexpr void forEachImpl(T &&node, Func &&func) {
  // Fork out to head and tail of the node
  forEachImpl(std::move(node.head), std::forward<Func>(func));
  forEachImpl(std::move(node.tail), std::forward<Func>(func));
}

template <typename Func>
constexpr void forEachImpl(Empty &&node, Func &&func) {
  // We've hit the root node and no further calls are made
}

template <typename T, typename R, typename Func>
constexpr void forEachImpl(Attribute<T, R> &&node, Func &&func) {
  func(std::move(node));
}

template <typename T, typename R, typename Func>
constexpr void forEachImpl(Attribute<T, R> &&node, Func &&func) {
  // This is called for each Attribute, and attribute 
  func(std::move(node));
}
{{< / highlight >}}

In `AutoProp<T>` base class we can leverage the fact that we've got `this` and create a function that takes a callable and calls it with `name` and `value` values taken from each `Attribute`.

{{< highlight cpp >}}
template <typename Function> void forEach(Function &&f) {
  auto &&names = static_cast<T *>(this)->getAttributeList();
  forEachImpl(names, [&](auto &&v) {
    auto && [ key, value ] = v; // Extract key/value
    f(std::move(key), static_cast<T *>(this)->*value); // Value needs "this" to get real value
  });
{{< /highlight >}}

# Uses

One of the most interesting uses for this is to do automatic serialization/deserialization to complex data formats such as JSON. 

Example code:

```
template <typename T> json to_json(AutoProp<T> &obj) {
  json j;
  obj.forEach([&](auto &&key, auto &&value) { j[key] = value; });
  return j;
}

template <typename T> T from_json(json j) {
  T obj;
  obj.forEach([&](auto &&key, auto &&value) { obj.set(key, j[key]); });
  return obj;
}
```

# Future steps

With reflection on the horizon targeted at C++20 there is little we can achieve with this code that the paper cannot. Nonetheless I found it quite useful when I had to expose a large data structure to the user, and give the ability to dynamically change the properties.

The code itself could be improved to provide a way to index the attributes by integer, which would make it easier to convert structures to `std::tuple`.

# Code

The code is available online: https://github.com/mpapierski/autoprop.